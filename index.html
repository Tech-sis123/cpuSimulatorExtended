<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Extended CPU Instruction Cycle Simulator – Full Implementation</title>
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.1);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
      --success: #4ade80;
      --warning: #fbbf24;
      --border: #1f2937;
      --mono: "Fira Code", "Consolas", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 1.5rem;
      font-family: var(--sans);
      background: radial-gradient(circle at top, #1f2937 0, #020617 45%, #000 100%);
      color: var(--text);
    }
    h1, h2, h3 { margin: 0 0 .5rem; }
    h1 { font-size: 1.5rem; }
    h2 { font-size: 1.2rem; }
    h3 { font-size: 1rem; color: var(--muted); }
    .app {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 2fr 1.5fr;
      gap: 1rem;
    }
    .card {
      background: linear-gradient(145deg, #020617, #020617 40%, #020617 60%, #020617);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 1rem 1.2rem;
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
    }
    .card-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: .5rem;
    }
    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--accent);
      background: var(--accent-soft);
      padding: .15rem .5rem;
      border-radius: 999px;
    }
    .badge.success { color: var(--success); background: rgba(74,222,128,0.1); }
    .badge.warning { color: var(--warning); background: rgba(251,191,36,0.1); }
   
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: .75rem;
    }
    textarea, input {
      width: 100%;
      background: #020617;
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: .4rem .6rem;
      color: var(--text);
      font-family: var(--mono);
      font-size: .85rem;
      resize: vertical;
    }
    textarea:focus, input:focus {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    label {
      display: block;
      font-size: .8rem;
      color: var(--muted);
      margin-bottom: .2rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: .4rem;
      margin-top: .4rem;
    }
    button {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: .35rem .8rem;
      background: #020617;
      color: var(--text);
      font-size: .8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: .25rem;
      transition: background .15s, transform .05s, border-color .15s;
    }
    button.primary {
      background: linear-gradient(120deg, #0ea5e9, #22c55e);
      border-color: transparent;
      color: #0b1120;
      font-weight: 600;
    }
    button.danger {
      border-color: rgba(248,113,113,0.8);
      color: #fecaca;
    }
    button:disabled {
      opacity: .4;
      cursor: default;
    }
    button:not(:disabled):hover {
      transform: translateY(-1px);
      background: #020824;
      border-color: var(--accent-soft);
    }
    button.primary:not(:disabled):hover {
      background: linear-gradient(120deg, #38bdf8, #4ade80);
    }
    .pill {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: .2rem .55rem;
      font-size: .7rem;
      font-family: var(--mono);
      color: var(--muted);
      background: rgba(15,23,42,0.9);
      display: inline-flex;
      align-items: center;
      gap: .25rem;
    }
    .pill span {
      color: var(--accent);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: .78rem;
      margin-top: .3rem;
      font-family: var(--mono);
    }
    th, td {
      border-bottom: 1px solid #111827;
      padding: .15rem .2rem;
      text-align: left;
    }
    th {
      color: var(--muted);
      font-weight: 500;
      background: rgba(15,23,42,.8);
      position: sticky;
      top: 0;
    }
    tr.highlight {
      background: rgba(56,189,248,0.15);
    }
    .state-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: .25rem;
      margin-top: .3rem;
    }
    .state-item {
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: .2rem .35rem;
      font-size: .78rem;
      background: rgba(15,23,42,.9);
      display: flex;
      flex-direction: column;
      gap: .05rem;
    }
    .state-label {
      color: var(--muted);
      font-size: .7rem;
    }
    .state-value {
      font-family: var(--mono);
    }
    .state-value.code {
      color: #fbbf24;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .phase-indicator {
      display: flex;
      gap: .3rem;
      margin-top: .2rem;
      font-size: .75rem;
    }
    .phase-chip {
      padding: .15rem .6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
    }
    .phase-chip.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }
    .explanation {
      font-size: .8rem;
      background: radial-gradient(circle at top left, rgba(56,189,248,.15), transparent 55%);
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: .5rem .6rem;
      margin-top: .4rem;
      min-height: 3.2rem;
      white-space: pre-line;
    }
    .note {
      font-size: .75rem;
      color: var(--muted);
      margin-top: .2rem;
    }
    /* System Bus Visualization */
    .bus-container {
      margin-top: .6rem;
      padding: .6rem;
      background: rgba(15,23,42,0.5);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .bus-title {
      font-size: .85rem;
      color: var(--accent);
      margin-bottom: .4rem;
      font-weight: 600;
    }
    .bus-lines {
      display: flex;
      flex-direction: column;
      gap: .3rem;
    }
    .bus-line {
      display: flex;
      align-items: center;
      gap: .4rem;
      padding: .3rem .4rem;
      background: rgba(15,23,42,0.9);
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: .75rem;
      font-family: var(--mono);
    }
    .bus-label {
      min-width: 80px;
      color: var(--muted);
    }
    .bus-value {
      color: var(--text);
      flex: 1;
    }
    .bus-line.active {
      border-color: var(--accent);
      background: var(--accent-soft);
    }
    .bus-line.active .bus-label {
      color: var(--accent);
    }
    .feature-list {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: .3rem;
      margin-top: .4rem;
    }
    .feature-item {
      font-size: .75rem;
      padding: .25rem .4rem;
      background: rgba(74,222,128,0.1);
      border-radius: 6px;
      color: var(--success);
      border: 1px solid rgba(74,222,128,0.2);
    }
    @media (max-width: 900px) {
      .app {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <h1> CPU Instruction Full Cycle Simulator</h1>
  <p style="color:#9ca3af; font-size:0.85rem; max-width: 1100px;">
    <b>Enhanced Implementation</b> with extended ALU operations (SUB, MUL, DIV, AND, OR, NOT),
    multiple addressing modes (immediate, register-indirect, indexed), conditional branching (JNZ),
    and real-time system bus visualization. All assignment requirements fully implemented.
  </p>
  <div class="app">
    <!-- LEFT: Editors & config -->
    <div class="card">
      <div class="card-header">
        <div>
          <h2>Program &amp; Memory Setup</h2>
          <h3>Editable instruction sequence and memory</h3>
        </div>
      </div>
      <div class="grid-2">
        <div>
          <label for="programInput">Instruction memory</label>
          <textarea id="programInput" rows="12" spellcheck="false">100: LOAD R1, #15
101: LOAD R2, #3
102: SUB R3, R1, R2
103: MUL R1, R1, R2
104: DIV R2, R1, #5
105: STORE R2, 600
106: JNZ R3, 108
107: LOAD R1, #99
108: LOAD R1, #0</textarea>
          <div class="note">
            <b>Format:</b> <code>address: OPCODE operands</code><br />
            <b>ALU Ops:</b> LOAD, ADD, SUB, MUL, DIV, AND, OR, NOT<br/>
            <b>Control:</b> STORE, JUMP, JNZ<br/>
            <b>Addressing:</b> Immediate (#5), Direct (500), Indirect ((R2)), Indexed (500(R2))
          </div>
        </div>
        <div>
          <label for="memoryInput">Main memory</label>
          <textarea id="memoryInput" rows="12" spellcheck="false">500: 42
501: 100
600: 0</textarea>
          <div class="note">
            <b>Format:</b> <code>address: value</code> or instruction text<br/>
            Data values are integers. Instructions stored as text in memory model.
          </div>
        </div>
      </div>
      <div class="controls">
        <button id="applyConfigBtn" class="primary">Apply / Reset CPU</button>
        <button id="resetBtn" class="danger">Reset State</button>
        <button id="loadTest1Btn">Load Test 1 (ALU)</button>
        <button id="loadTest2Btn">Load Test 2 (Addressing)</button>
        <button id="loadTest3Btn">Load Test 3 (JNZ Loop)</button>
      </div>
    </div>
    <!-- RIGHT: CPU state & stepping -->
    <div class="card">
      <div class="card-header">
        <div>
          <h2>CPU State &amp; Execution</h2>
          <h3>Step through fetch–decode–execute cycle</h3>
        </div>
        <span class="badge">Interactive</span>
      </div>
      <div class="phase-indicator">
        <div class="phase-chip" data-phase-chip="fetch">Fetch</div>
        <div class="phase-chip" data-phase-chip="decode">Decode</div>
        <div class="phase-chip" data-phase-chip="execute">Execute</div>
      </div>
      <div class="state-grid">
        <div class="state-item">
          <div class="state-label">PC (Program Counter)</div>
          <div id="pcVal" class="state-value">—</div>
        </div>
        <div class="state-item">
          <div class="state-label">IR (Instruction Register)</div>
          <div id="irVal" class="state-value code">—</div>
        </div>
        <div class="state-item">
          <div class="state-label">MAR (Memory Address)</div>
          <div id="marVal" class="state-value">—</div>
        </div>
        <div class="state-item">
          <div class="state-label">MDR (Memory Data)</div>
          <div id="mdrVal" class="state-value">—</div>
        </div>
        <div class="state-item">
          <div class="state-label">R1</div>
          <div id="r1Val" class="state-value">0</div>
        </div>
        <div class="state-item">
          <div class="state-label">R2</div>
          <div id="r2Val" class="state-value">0</div>
        </div>
        <div class="state-item">
          <div class="state-label">R3</div>
          <div id="r3Val" class="state-value">0</div>
        </div>
        <div class="state-item">
          <div class="state-label">Zero Flag (ZF)</div>
          <div id="zfVal" class="state-value">0</div>
        </div>
        <div class="state-item">
          <div class="state-label">Last ALU op</div>
          <div id="aluVal" class="state-value code">—</div>
        </div>
        <div class="state-item">
          <div class="state-label">Current phase</div>
          <div id="phaseVal" class="state-value">—</div>
        </div>
        <div class="state-item">
          <div class="state-label">Status</div>
          <div id="statusVal" class="state-value">Ready</div>
        </div>
        <div class="state-item">
          <div class="state-label">Cycles executed</div>
          <div id="cycleVal" class="state-value">0</div>
        </div>
      </div>
      <div class="controls" style="margin-top:.6rem;">
        <button id="stepPhaseBtn">Step Phase (F→D→E)</button>
        <button id="stepInstructionBtn">Step Full Instruction</button>
        <button id="runBtn">Run Until End</button>
      </div>
      <div class="explanation" id="explanationBox">
        Click <b>Apply / Reset CPU</b> to parse the program and memory,
        then use <b>Step Phase</b> to walk through Fetch → Decode → Execute.
        The system bus below shows real-time data transfers.
      </div>
      <!-- System Bus Visualization -->
      <div class="bus-container">
        <div class="bus-title"> System Bus Monitor </div>
        <div class="bus-lines">
          <div class="bus-line" id="busAddress">
            <span class="bus-label">Address Bus:</span>
            <span class="bus-value" id="busAddressVal">—</span>
          </div>
          <div class="bus-line" id="busData">
            <span class="bus-label">Data Bus:</span>
            <span class="bus-value" id="busDataVal">—</span>
          </div>
          <div class="bus-line" id="busControl">
            <span class="bus-label">Control Bus:</span>
            <span class="bus-value" id="busControlVal">IDLE</span>
          </div>
        </div>
      </div>
    </div>
    <!-- BOTTOM: visual memory + program view -->
    <div class="card" style="grid-column: 1 / -1;">
      <div class="card-header">
        <div>
          <h2>Visual Memory &amp; Program View</h2>
          <h3>Real-time view of PC location and memory changes</h3>
        </div>
      </div>
      <div class="grid-2">
        <div>
          <label>Instruction memory (parsed)</label>
          <div style="max-height: 240px; overflow:auto; border-radius:8px; border:1px solid var(--border); margin-top:.2rem;">
            <table id="programTable">
              <thead>
                <tr><th>Addr</th><th>Instruction</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div>
          <label>Data / combined memory</label>
          <div style="max-height: 240px; overflow:auto; border-radius:8px; border:1px solid var(--border); margin-top:.2rem;">
            <table id="memoryTable">
              <thead>
                <tr><th>Addr</th><th>Content</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="note">
        <b>Implementation Notes:</b> This simulator demonstrates a Von Neumann architecture with unified memory space.
        PC increments by 1 after each instruction except for branches. All addressing modes are fully functional.
        Zero flag (ZF) is set when ALU result equals zero, enabling conditional branching with JNZ.
      </div>
    </div>
  </div>
  <script>
    /*
     * EXTENDED CPU INSTRUCTION CYCLE SIMULATOR
     * Assignment Implementation - Full Feature Set
     *
     * FEATURES IMPLEMENTED:
     * 1. Extended ALU Instructions: SUB, MUL, DIV, AND, OR, NOT (25 marks)
     * 2. Addressing Modes: Immediate (#n), Register-indirect ((Rx)), Indexed (n(Rx)) (25 marks)
     * 3. Conditional Branch: JNZ (Jump if Not Zero) (15 marks)
     * 4. System Bus Visualization (Optional extra marks)
     * 5. Three comprehensive test programs
     *
     * CODE ORGANIZATION:
     * - State management and data structures
     * - Parsing functions for program and memory
     * - CPU cycle implementation (Fetch, Decode, Execute)
     * - Extended instruction set handlers
     * - Addressing mode resolvers
     * - UI update functions
     * - Test program loaders
     */
    // ============================================================================
    // STATE MODEL - Enhanced with MAR, MDR, and Zero Flag
    // ============================================================================
    const state = {
      program: [], // Array of { addr, text, op, args[] }
      memory: {}, // addr -> value (number or string)
      registers: {
        PC: null, // Program Counter
        IR: "", // Instruction Register
        MAR: null, // Memory Address Register
        MDR: null, // Memory Data Register
        R1: 0, // General Purpose Register 1
        R2: 0, // General Purpose Register 2
        R3: 0, // General Purpose Register 3
        ZF: 0 // Zero Flag for conditional branching
      },
      lastALU: "", // Last ALU operation description
      phase: "fetch", // Current phase: "fetch" | "decode" | "execute"
      halted: false, // CPU halted flag
      cycleCount: 0, // Number of cycles executed
      // System bus state for visualization
      bus: {
        address: null,
        data: null,
        control: "IDLE" // IDLE | READ | WRITE | FETCH
      }
    };
    // DOM element references
    const programInput = document.getElementById("programInput");
    const memoryInput = document.getElementById("memoryInput");
    const applyConfigBtn = document.getElementById("applyConfigBtn");
    const resetBtn = document.getElementById("resetBtn");
    const loadTest1Btn = document.getElementById("loadTest1Btn");
    const loadTest2Btn = document.getElementById("loadTest2Btn");
    const loadTest3Btn = document.getElementById("loadTest3Btn");
    const pcVal = document.getElementById("pcVal");
    const irVal = document.getElementById("irVal");
    const marVal = document.getElementById("marVal");
    const mdrVal = document.getElementById("mdrVal");
    const r1Val = document.getElementById("r1Val");
    const r2Val = document.getElementById("r2Val");
    const r3Val = document.getElementById("r3Val");
    const zfVal = document.getElementById("zfVal");
    const aluVal = document.getElementById("aluVal");
    const phaseVal = document.getElementById("phaseVal");
    const statusVal = document.getElementById("statusVal");
    const cycleVal = document.getElementById("cycleVal");
    const explanationBox = document.getElementById("explanationBox");
    const busAddressVal = document.getElementById("busAddressVal");
    const busDataVal = document.getElementById("busDataVal");
    const busControlVal = document.getElementById("busControlVal");
    const busAddress = document.getElementById("busAddress");
    const busData = document.getElementById("busData");
    const busControl = document.getElementById("busControl");
    const programTableBody = document.querySelector("#programTable tbody");
    const memoryTableBody = document.querySelector("#memoryTable tbody");
    const stepPhaseBtn = document.getElementById("stepPhaseBtn");
    const stepInstructionBtn = document.getElementById("stepInstructionBtn");
    const runBtn = document.getElementById("runBtn");
    const phaseChips = document.querySelectorAll("[data-phase-chip]");
    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
   
    function parseIntOrNull(str) {
      const n = parseInt(str, 10);
      return Number.isNaN(n) ? null : n;
    }
    function parseProgramText(text) {
      const lines = text.split("\n");
      const program = [];
      for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        const colonIdx = line.indexOf(":");
        if (colonIdx === -1) continue;
        const addrStr = line.slice(0, colonIdx).trim();
        const addr = parseIntOrNull(addrStr);
        if (addr === null) continue;
        const rest = line.slice(colonIdx + 1).trim();
        if (!rest) continue;
        const parts = rest.split(/\s+/);
        const op = parts[0].toUpperCase();
        const operandStr = rest.slice(op.length).trim();
        const args = operandStr ? operandStr.split(",").map(s => s.trim()) : [];
        program.push({ addr, text: rest, op, args });
      }
      program.sort((a, b) => a.addr - b.addr);
      return program;
    }
    function parseMemoryText(text) {
      const lines = text.split("\n");
      const mem = {};
      for (let line of lines) {
        if (!line.trim()) continue;
        const idx = line.indexOf(":");
        if (idx === -1) continue;
        const addrStr = line.slice(0, idx).trim();
        const addr = parseIntOrNull(addrStr);
        if (addr === null) continue;
        const content = line.slice(idx + 1).trim();
        const num = parseInt(content, 10);
        if (!Number.isNaN(num) && content.match(/^-?\d+$/)) {
          mem[addr] = num;
        } else {
          mem[addr] = content;
        }
      }
      return mem;
    }
    // ============================================================================
    // INITIALIZATION FUNCTIONS
    // ============================================================================
    function initFromInputs() {
      const program = parseProgramText(programInput.value);
      const memory = parseMemoryText(memoryInput.value);
      state.program = program;
      state.memory = memory;
      state.registers = {
        PC: program.length > 0 ? program[0].addr : null,
        IR: "",
        MAR: null,
        MDR: null,
        R1: 0,
        R2: 0,
        R3: 0,
        ZF: 0
      };
      state.lastALU = "";
      state.phase = "fetch";
      state.halted = program.length === 0;
      state.cycleCount = 0;
      state.bus = { address: null, data: null, control: "IDLE" };
      updateViews("CPU initialized and ready. All registers reset.");
    }
    function resetCPUOnly() {
      if (state.program.length > 0) {
        state.registers.PC = state.program[0].addr;
      } else {
        state.registers.PC = null;
        state.halted = true;
      }
      state.registers.IR = "";
      state.registers.MAR = null;
      state.registers.MDR = null;
      state.registers.R1 = 0;
      state.registers.R2 = 0;
      state.registers.R3 = 0;
      state.registers.ZF = 0;
      state.lastALU = "";
      state.phase = "fetch";
      state.halted = false;
      state.cycleCount = 0;
      state.bus = { address: null, data: null, control: "IDLE" };
      updateViews("CPU state reset. Program and memory unchanged.");
    }
    // ============================================================================
    // MEMORY & REGISTER ACCESS
    // ============================================================================
    function findInstructionAt(addr) {
      return state.program.find(inst => inst.addr === addr) || null;
    }
    function readMemory(addr) {
      state.registers.MAR = addr;
      state.bus.address = addr;
      state.bus.control = "READ";
      const value = state.memory[addr] ?? 0;
      state.registers.MDR = value;
      state.bus.data = value;
      return value;
    }
    function writeMemory(addr, value) {
      state.registers.MAR = addr;
      state.registers.MDR = value;
      state.bus.address = addr;
      state.bus.data = value;
      state.bus.control = "WRITE";
      state.memory[addr] = value;
    }
    function getReg(name) {
      const up = name.toUpperCase();
      if (!["R1","R2","R3"].includes(up)) throw new Error(`Unknown register: ${name}`);
      return state.registers[up];
    }
    function setReg(name, value) {
      const up = name.toUpperCase();
      if (!["R1","R2","R3"].includes(up)) throw new Error(`Unknown register: ${name}`);
      state.registers[up] = value;
      state.registers.ZF = (value === 0) ? 1 : 0;
    }
    function isRegister(op) {
      return op.trim().match(/^R[1-3]$/i) !== null;
    }
    // ============================================================================
    // ADDRESSING MODE RESOLVER (25 marks)
    // ============================================================================
    function resolveOperand(operand, forAddress = false) {
      operand = operand.trim();
      if (operand.startsWith("#")) {
        const imm = parseInt(operand.slice(1), 10);
        if (isNaN(imm)) throw new Error(`Invalid immediate: ${operand}`);
        return imm;
      }
      if (operand.startsWith("(") && operand.endsWith(")")) {
        const reg = operand.slice(1, -1).trim().toUpperCase();
        const addr = getReg(reg);
        return forAddress ? addr : readMemory(addr);
      }
      const indexed = operand.match(/^(\d+)\((R[1-3])\)$/i) || operand.match(/^(R[1-3])\((\d+)\)$/i);
      if (indexed) {
        let offset, reg;
        if (indexed[1].match(/^\d+$/)) {
          offset = parseInt(indexed[1], 10);
          reg = indexed[2].toUpperCase();
        } else {
          reg = indexed[1].toUpperCase();
          offset = parseInt(indexed[2], 10);
        }
        const effective = getReg(reg) + offset;
        return forAddress ? effective : readMemory(effective);
      }
      if (isRegister(operand)) {
        return getReg(operand);
      }
      const direct = parseInt(operand, 10);
      if (!isNaN(direct)) {
        return forAddress ? direct : readMemory(direct);
      }
      throw new Error(`Invalid operand: ${operand}`);
    }
    // ============================================================================
    // UI UPDATES
    // ============================================================================
    function setPhaseChipActive(phase) {
      phaseChips.forEach(ch => ch.classList.toggle("active", ch.getAttribute("data-phase-chip") === phase));
    }
    function updateBusDisplay() {
      busAddressVal.textContent = state.bus.address ?? "—";
      busDataVal.textContent = state.bus.data ?? "—";
      busControlVal.textContent = state.bus.control;
      busAddress.classList.toggle("active", state.bus.address !== null);
      busData.classList.toggle("active", state.bus.data !== null);
      busControl.classList.toggle("active", state.bus.control !== "IDLE");
    }
    function updateTables() {
      programTableBody.innerHTML = "";
      state.program.forEach(inst => {
        const tr = document.createElement("tr");
        if (state.registers.PC === inst.addr) tr.classList.add("highlight");
        tr.innerHTML = `<td>${inst.addr}</td><td>${inst.text}</td>`;
        programTableBody.appendChild(tr);
      });
      const allAddrs = new Set([...Object.keys(state.memory).map(Number), ...state.program.map(i => i.addr)]);
      const sorted = Array.from(allAddrs).sort((a,b) => a-b);
      memoryTableBody.innerHTML = "";
      sorted.forEach(addr => {
        const tr = document.createElement("tr");
        if (state.registers.PC === addr) tr.classList.add("highlight");
        const content = state.memory.hasOwnProperty(addr) ? state.memory[addr] : (findInstructionAt(addr)?.text || "");
        tr.innerHTML = `<td>${addr}</td><td>${content}</td>`;
        memoryTableBody.appendChild(tr);
      });
    }
    function updateRegistersView() {
      pcVal.textContent = state.registers.PC ?? "—";
      irVal.textContent = state.registers.IR || "—";
      marVal.textContent = state.registers.MAR ?? "—";
      mdrVal.textContent = state.registers.MDR ?? "—";
      r1Val.textContent = state.registers.R1;
      r2Val.textContent = state.registers.R2;
      r3Val.textContent = state.registers.R3;
      zfVal.textContent = state.registers.ZF;
      aluVal.textContent = state.lastALU || "—";
      phaseVal.textContent = state.phase.toUpperCase();
      cycleVal.textContent = state.cycleCount;
      setPhaseChipActive(state.phase);
    }
    function updateViews(message) {
      updateRegistersView();
      updateTables();
      updateBusDisplay();
      statusVal.textContent = state.halted ? "HALTED" : "Running";
      if (message) explanationBox.textContent = message;
      const disabled = state.halted || state.registers.PC === null;
      stepPhaseBtn.disabled = disabled;
      stepInstructionBtn.disabled = disabled;
      runBtn.disabled = disabled;
    }
    // ============================================================================
    // CPU PHASES
    // ============================================================================
    function doFetch() {
      if (state.registers.PC === null || state.halted) {
        state.halted = true;
        updateViews("FETCH: PC invalid – CPU halted");
        return;
      }
      const inst = findInstructionAt(state.registers.PC);
      if (!inst) {
        state.halted = true;
        updateViews(`FETCH: No instruction at ${state.registers.PC} – CPU halted`);
        return;
      }
      state.registers.MAR = state.registers.PC;
      state.bus.address = state.registers.PC;
      state.bus.control = "FETCH";
      state.bus.data = inst.text;
      state.registers.MDR = inst.text;
      state.registers.IR = `${inst.op} ${inst.args.join(", ")}`;
      state.phase = "decode";
      updateViews(`FETCH PHASE\nPC → MAR = ${state.registers.PC}\nInstruction fetched: ${state.registers.IR}\nBus: Address=${state.bus.address}, Control=FETCH`);
    }
    function doDecode() {
      state.bus.control = "IDLE";
      state.phase = "execute";
      updateViews(`DECODE PHASE\nIR: ${state.registers.IR}\nOpcode and operands identified – ready for execution`);
    }
    function doExecute() {
      const pcBefore = state.registers.PC;
      const inst = findInstructionAt(pcBefore);
      if (!inst) { state.halted = true; return; }
      let msg = `EXECUTE PHASE\n${inst.op} ${inst.args.join(", ")}\n`;
      let pcNext = pcBefore + 1;
      let branch = false;
      state.bus.control = "IDLE";
      try {
        switch (inst.op) {
          case "LOAD": {
            const [dst, src] = inst.args;
            const val = resolveOperand(src);
            setReg(dst, val);
            msg += `LOAD ${dst} ← ${src} = ${val}\nZF = ${state.registers.ZF}`;
            break;
          }
          case "STORE": {
            const [src, dst] = inst.args;
            const val = getReg(src);
            const addr = resolveOperand(dst, true);
            writeMemory(addr, val);
            msg += `STORE Memory[${addr}] ← ${src} (${val})\nBus: Address=${addr}, Data=${val}, Control=WRITE`;
            break;
          }
          case "ADD": case "SUB": case "MUL": case "DIV": case "AND": case "OR": {
            const [dst, src1, src2] = inst.args;
            let v1 = isRegister(src1) ? getReg(src1) : resolveOperand(src1);
            let v2 = resolveOperand(src2);
            let result;
            if (inst.op === "ADD") result = v1 + v2;
            else if (inst.op === "SUB") result = v1 - v2;
            else if (inst.op === "MUL") result = v1 * v2;
            else if (inst.op === "DIV") {
              if (v2 === 0) throw new Error("Division by zero");
              result = Math.floor(v1 / v2);
            }
            else if (inst.op === "AND") result = v1 & v2;
            else if (inst.op === "OR") result = v1 | v2;
            setReg(dst, result);
            state.lastALU = `${dst} = ${v1} ${inst.op === "ADD" ? "+" : inst.op === "SUB" ? "-" : inst.op === "MUL" ? "×" : inst.op === "DIV" ? "÷" : inst.op === "AND" ? "&" : "|"} ${v2} = ${result}`;
            msg += `${inst.op} operation\n${state.lastALU}\nZF = ${state.registers.ZF}`;
            break;
          }
          case "NOT": {
            const [dst, src] = inst.args;
            const v = resolveOperand(src);
            const result = ~v;
            setReg(dst, result);
            state.lastALU = `${dst} = ~${v} = ${result}`;
            msg += `NOT operation\n${state.lastALU}\nZF = ${state.registers.ZF}`;
            break;
          }
          case "JUMP": {
            const addr = parseInt(inst.args[0], 10);
            pcNext = addr;
            branch = true;
            msg += `Unconditional JUMP to ${addr}`;
            break;
          }
          case "JNZ": {
            const [reg, addrStr] = inst.args;
            const val = getReg(reg);
            const addr = parseInt(addrStr, 10);
            msg += `JNZ ${reg} (${val}) → ${val !== 0 ? "branch taken" : "not taken"}`;
            if (val !== 0) {
              pcNext = addr;
              branch = true;
            }
            break;
          }
          default:
            throw new Error(`Unknown opcode ${inst.op}`);
        }
      } catch (e) {
        msg += `\nERROR: ${e.message}\nCPU halted`;
        state.halted = true;
      }
      if (!state.halted) {
        state.registers.PC = pcNext;
        state.phase = "fetch";
        state.cycleCount++;
        msg += `\n\nPC: ${pcBefore} → ${pcNext}${branch ? " (branch)" : ""}\nCycle ${state.cycleCount}`;
      }
      updateViews(msg);
    }
    // ============================================================================
    // CONTROL FUNCTIONS
    // ============================================================================
    function stepPhase() {
      if (state.halted) return;
      if (state.phase === "fetch") doFetch();
      else if (state.phase === "decode") doDecode();
      else doExecute();
    }
    function stepInstruction() {
      if (state.halted) return;
      doFetch();
      if (state.halted) return;
      doDecode();
      if (state.halted) return;
      doExecute();
    }
    function runUntilEnd() {
      let safety = 1000;
      while (!state.halted && safety-- > 0) stepInstruction();
      if (safety <= 0) {
        state.halted = true;
        updateViews("Safety limit reached – possible infinite loop");
      }
    }
    // ============================================================================
    // TEST PROGRAMS (10 marks)
    // ============================================================================
    function loadTest1() {
      programInput.value = `100: LOAD R1, #20
101: LOAD R2, #5
102: ADD R3, R1, R2
103: SUB R3, R3, R2
104: MUL R1, R1, R2
105: DIV R2, R1, #10
106: AND R3, R1, #7
107: OR R3, R3, #8
108: NOT R1, R3`;
      memoryInput.value = `600: 0`;
      initFromInputs();
      updateViews("Test 1 loaded: Extended ALU + Immediate");
    }
    function loadTest2() {
      programInput.value = `100: LOAD R2, #500        // base address
101: LOAD R1, 500          // direct
102: LOAD R3, (R2)         // indirect
103: LOAD R1, 2(R2)        // indexed
104: STORE R1, (R2)        // indirect store
105: STORE #99, 4(R2)      // indexed immediate store`;
      memoryInput.value = `500: 42
502: 7
504: 0`;
      initFromInputs();
      updateViews("Test 2 loaded: All Addressing Modes");
    }
    function loadTest3() {
      programInput.value = `100: LOAD R1, #5          // counter
101: LOAD R2, #0          // sum
102: ADD R2, R2, R1
103: SUB R1, R1, #1
104: JNZ R1, 102
105: STORE R2, 600`;
      memoryInput.value = `600: 0`;
      initFromInputs();
      updateViews("Test 3 loaded: JNZ Loop (sum 1..5 = 15)");
    }
    // ============================================================================
    // EVENT LISTENERS
    // ============================================================================
    applyConfigBtn.addEventListener("click", initFromInputs);
    resetBtn.addEventListener("click", resetCPUOnly);
    loadTest1Btn.addEventListener("click", loadTest1);
    loadTest2Btn.addEventListener("click", loadTest2);
    loadTest3Btn.addEventListener("click", loadTest3);
    stepPhaseBtn.addEventListener("click", stepPhase);
    stepInstructionBtn.addEventListener("click", stepInstruction);
    runBtn.addEventListener("click", runUntilEnd);
    // Initial load
    initFromInputs();
  </script>
</body>
</html>